#pragma once

// C++ includes
#include <complex>
#include <cstdio>

// MaCh3 includes
#include "Fitters/StatisticalUtils.h"
#include "Samples/HistogramUtils.h"
#include "Parameters/ParameterHandlerUtils.h"

_MaCh3_Safe_Include_Start_ //{
// ROOT includes
#include "TFile.h"
#include "TBranch.h"
#include "TCanvas.h"
#include "TLine.h"
#include "TLegend.h"
#include "TString.h"
#include "TGraphErrors.h"
#include "TVectorD.h"
#include "TColor.h"
#include "TStyle.h"
#include "TStopwatch.h"
#include "TText.h"
#include "TGaxis.h"
#include "TTree.h"
#include "TROOT.h"
#include "TKey.h"
#include "TRandom3.h"
#include "TGraphPolar.h"
#include "TCandle.h"
#include "TMath.h"
#include "TMatrixDSymEigen.h"
#include "TVirtualFFT.h"
_MaCh3_Safe_Include_End_ //}


//KS: Joy of forward declaration https://gieseanw.wordpress.com/2018/02/25/the-joys-of-forward-declarations-results-from-the-real-world/
class TChain;
class TF1;
class MCMCProcessorGPU;

/// @todo KS: Implement Diagnostics/GetPenaltyTerm.cpp here.
/// KS: Enum for different covariance classes
enum ParameterEnum {
  kXSecPar  = 0,
  kNDPar    = 1,
  kFDDetPar = 2,
  
  kNParameterEnum = 3 //KS: keep it at the end to keep track of all parameters
};

/// @brief Class responsible for processing MCMC chains, performing diagnostics, generating plots, and managing Bayesian analysis.
/// @details This class provides utilities to handle MCMC output generated by mcmc::runMCMC. It is particularly useful for extracting values from previous MCMC runs and initiating new MCMC runs with those values. Inspired by nd280_utils/DrawComp.cpp.
/// @see For more details and examples, visit the [Wiki](https://github.com/mach3-software/MaCh3/wiki/09.-Bayesian-Analysis,-Plotting-and-MCMC-Processor).
/// @author Clarence Wret
/// @author Kamil Skwarczynski
class MCMCProcessor {
  public:
    /// @brief Constructs an MCMCProcessor object with the specified input file and options.
    /// @param InputFile The path to the input file containing MCMC data.
    MCMCProcessor(const std::string &InputFile);
    /// @brief Destroys the MCMCProcessor object.
    virtual ~MCMCProcessor();

    /// @brief Scan chain, what parameters we have and load information from covariance matrices
    void Initialise();
    /// @brief Make 1D projection for each parameter and prepare structure
    void MakePostfit(const std::map<std::string, std::pair<double, double>>& Edges = {});
    /// @brief Calculate covariance by making 2D projection of each combination of parameters
    /// @warning This is deprecated and slower, however it is less RAM intensive
    void MakeCovariance();
    /// @brief KS:By caching each step we use multithreading
    void CacheSteps();
    /// @brief Calculate covariance by making 2D projection of each combination of parameters using multithreading
    /// @param Mute Allow silencing many messages, especially important if we calculate matrix many times
    void MakeCovariance_MP(const bool Mute = false);
    /// @brief Make and Draw SubOptimality
    /// @cite roberts2009adaptive
    /// @author Henry Wallace
    void MakeSubOptimality(const int NIntervals = 10);

    /// @brief Reset 2D posteriors, in case we would like to calculate in again with different BurnInCut
    void Reset2DPosteriors();
        
    /// @brief Draw the post-fit comparisons
    void DrawPostfit();
    /// @brief Make and Draw Violin
    void MakeViolin();
    /// @brief Make and Draw Credible intervals
    /// @param CredibleIntervals Vector with values of credible intervals, must be in descending order
    /// @param CredibleIntervalsColours Color_t telling what colour to use for each Interval line
    /// @param CredibleInSigmas Bool telling whether intervals are in percentage or in sigmas, then special conversions is used
    void MakeCredibleIntervals(const std::vector<double>& CredibleIntervals = {0.99, 0.90, 0.68 },
                               const std::vector<Color_t>& CredibleIntervalsColours = {kCyan+4, kCyan-2, kCyan-10},
                               const bool CredibleInSigmas = false
                               );
    /// @brief Draw the post-fit covariances
    void DrawCovariance();
    /// @brief Make YAML file from post-fit covariance
    void MakeCovarianceYAML(const std::string& OutputYAMLFile, const std::string& MeansMethod) const;
    /// @brief Make and Draw Credible Regions
    /// @param CredibleRegions Vector with values of credible intervals, must be in descending order
    /// @param CredibleRegionStyle Style_t telling what line style to use for each Interval line
    /// @param CredibleRegionColor Color_t telling what colour to use for each Interval line
    /// @param CredibleInSigmas Bool telling whether intervals are in percentage or in sigmas, then special conversions is used
    void MakeCredibleRegions(const std::vector<double>& CredibleRegions = {0.99, 0.90, 0.68},
                             const std::vector<Style_t>& CredibleRegionStyle = {kDashed, kSolid, kDotted},
                             const std::vector<Color_t>& CredibleRegionColor = {kGreen-3, kGreen-10, kGreen},
                             const bool CredibleInSigmas = false,
                             const bool Draw2DPosterior = true,
                             const bool DrawBestFit = true
                             );
    /// @brief Make fancy triangle plot for selected parameters
    /// @param CredibleIntervals Vector with values of credible intervals, must be in descending order
    /// @param CredibleIntervalsColours Color_t telling what colour to use for each Interval line
    /// @param CredibleInSigmas Bool telling whether intervals are in percentage or in sigmas, then special conversions is used
    /// @param CredibleRegions Vector with values of credible intervals, must be in descending order
    /// @param CredibleRegionStyle Style_t telling what line style to use for each Interval line
    /// @param CredibleRegionColor Color_t telling what colour to use for each Interval line
    void MakeTrianglePlot(const std::vector<std::string>& ParNames,
                          // 1D
                          const std::vector<double>& CredibleIntervals = {0.99, 0.90, 0.68 },
                          const std::vector<Color_t>& CredibleIntervalsColours = {kCyan+4, kCyan-2, kCyan-10},
                          //2D
                          const std::vector<double>& CredibleRegions = {0.99, 0.90, 0.68},
                          const std::vector<Style_t>& CredibleRegionStyle = {kDashed, kSolid, kDotted},
                          const std::vector<Color_t>& CredibleRegionColor = {kGreen-3, kGreen-10, kGreen},
                          // Other
                          const bool CredibleInSigmas = false
                          );

    /// @brief Checks the order and size consistency of the `CredibleIntervals` and `CredibleIntervalsColours` vectors.
    /// @param CredibleIntervals A vector of credible interval values.
    /// @param CredibleIntervalsColours A vector of colors associated with each credible interval.
    /// @throws MaCh3Exception If the sizes are not equal or the intervals are not in decreasing order.
    void CheckCredibleIntervalsOrder(const std::vector<double>& CredibleIntervals, const std::vector<Color_t>& CredibleIntervalsColours) const;

    /// @brief Checks the order and size consistency of the `CredibleRegions`, `CredibleRegionStyle`, and `CredibleRegionColor` vectors.
    /// @param CredibleRegions A vector of credible region values.
    /// @param CredibleRegionStyle A vector of styles associated with each credible region.
    /// @param CredibleRegionColor A vector of colors associated with each credible region.
    /// @throws MaCh3Exception If the sizes are not equal or the regions are not in decreasing order.
    void CheckCredibleRegionsOrder(const std::vector<double>& CredibleRegions,
                                   const std::vector<Style_t>& CredibleRegionStyle,
                                   const std::vector<Color_t>& CredibleRegionColor);

    /// @brief Make funny polar plot
    /// @param ParNames Vector with parameter names for which Polar Plot will be made
    void GetPolarPlot(const std::vector<std::string>& ParNames);

    /// @brief Calculate Bayes factor for vector of params, and model boundaries
    /// @param ParName Vector with parameter names for which we calculate Bayes factor
    /// @param Model1Bounds Lower and upper bound for hypothesis 1. Within this bound we calculate integral used later for Bayes Factor
    /// @param Model2Bounds Lower and upper bound for hypothesis 2. Within this bound we calculate integral used later for Bayes Factor
    /// @param ModelNames Names for hypothesis 1 and 2
    void GetBayesFactor(const std::vector<std::string>& ParName,
                        const std::vector<std::vector<double>>& Model1Bounds,
                        const std::vector<std::vector<double>>& Model2Bounds,
                        const std::vector<std::vector<std::string>>& ModelNames);
    /// @brief Calculate Bayes factor for point like hypothesis using SavageDickey
    void GetSavageDickey(const std::vector<std::string>& ParName,
                         const std::vector<double>& EvaluationPoint,
                         const std::vector<std::vector<double>>& Bounds);

    /// @brief Produce Savage Dickey plot
    /// @param PriorHist Histogram with prior distribution
    /// @param PosteriorHist Histogram with posterior distribution
    void SavageDickeyPlot(std::unique_ptr<TH1D>& PriorHist,
                          std::unique_ptr<TH1D>& PosteriorHist,
                          const std::string& Title,
                          const double EvaluationPoint) const ;

    /// @brief Reweight Prior by giving new central value and new error
    /// @param Names Parameter names for which we do reweighting
    /// @param NewCentral New central value for which we reweight
    /// @param NewError New error used for calculating weight
    void ReweightPrior(const std::vector<std::string>& Names,
                       const std::vector<double>& NewCentral,
                       const std::vector<double>& NewError);
    

    /// @brief Smear chain contours
    /// @param Names Parameter names for which we do smearing
    /// @param Error Error based on which we smear
    /// @param SaveBranch Whether we save unsmeared branch or not
    void SmearChain(const std::vector<std::string>& Names,
                    const std::vector<double>& NewCentral,
                    const bool& SaveBranch) const;

    /// @brief Make .gif of parameter evolution
    /// @param Names Parameter names for which we do .gif
    /// @param NIntervals Number of intervals for a gif
    void ParameterEvolution(const std::vector<std::string>& Names,
                            const std::vector<int>& NIntervals);

    /// @brief Thin MCMC Chain, to save space and maintain low autocorrelations.
    /// @param ThinningCut every which entry you want to thin
    /// @param Average If true will perform MCMC averaging instead of thinning
    inline void ThinMCMC(const int ThinningCut) const { ThinningMCMC(MCMCFile+".root", ThinningCut); };

    /// @brief KS: Perform MCMC diagnostic including Autocorrelation, Trace etc.
    void DiagMCMC();
    
    // Get the number of parameters
    /// @brief Get total number of used parameters
    inline int GetNParams() const { return nDraw; };
    inline int GetNXSec() const { return nParam[kXSecPar]; };
    inline int GetNND() const { return nParam[kNDPar]; };
    inline int GetNFD() const { return nParam[kFDDetPar]; };

    /// @brief Get Yaml config obtained from a Chain
    YAML::Node GetCovConfig(const int i) const {return CovConfig.at(i); }

    /// @brief Number of params from a given group, for example flux
    int GetGroup(const std::string& name) const;

    /// @brief Get 1D posterior for a given parameter
    /// @param i parameter index
    inline TH1D* GetHpost(const int i) const { return hpost[i]; };
    /// @brief Get 2D posterior for a given parameter combination
    /// @param i parameter index X
    /// @param j parameter index Y
    inline TH2D* GetHpost2D(const int i, const int j) const { return hpost2D[i][j]; };
    /// @brief Get Violin plot for all parameters with posterior values
    inline TH2D* GetViolin() const { return hviolin.get(); };
    /// @brief Get Violin plot for all parameters with prior values
    inline TH2D* GetViolinPrior() const { return hviolin_prior.get(); };

    //Covariance getters
    inline std::vector<std::string> GetXSecCov()  const { return CovPos[kXSecPar]; };
    inline std::string GetNDCov() const { return CovPos[kNDPar].back(); };
    inline std::string GetFDCov() const { return CovPos[kFDDetPar].back(); };

    /// @brief Get the post-fit results (arithmetic and Gaussian)
    void GetPostfit(TVectorD *&Central, TVectorD *&Errors, TVectorD *&Central_Gauss, TVectorD *&Errors_Gauss, TVectorD *&Peaks);
    /// @brief Get the post-fit covariances and correlations
    /// @param Cov Covariance matrix
    /// @param Corr Correlation matrix
    void GetCovariance(TMatrixDSym *&Cov, TMatrixDSym *&Corr);
    /// @brief Or the individual post-fits
    void GetPostfit_Ind(TVectorD *&Central, TVectorD *&Errors, TVectorD *&Peaks, ParameterEnum kParam);
    
    /// @brief Get the vector of branch names from root file
    const std::vector<TString>& GetBranchNames() const { return BranchNames;};
    /// @brief Get properties of parameter by passing it number
    void GetNthParameter(const int param, double &Prior, double &PriorError, TString &Title) const;
    /// @brief Get parameter number based on name
    int GetParamIndexFromName(const std::string& Name) const;
    /// @brief Get Number of entries that Chain has, for merged chains will not be the same Nsteps
    inline Long64_t GetnEntries(){return nEntries;};
    /// @brief Get Number of Steps that Chain has, for merged chains will not be the same nEntries
    inline Long64_t GetnSteps(){return nSteps;};
    /// @brief Modify number of bins used for 1D and 2D Histograms
    inline void SetNBins(const int NewBins) {nBins = NewBins;};

    /// @brief Set number of entries to make potentially MCMC Processing faster
    /// @warning This option only sets an upper limit; burn-in events will NOT be discarded
    inline void SetEntries(const int NewEntries) {
      if (NewEntries > nEntries) {
        MACH3LOG_ERROR("Cannot increase entries from {} to {}. Only decreasing is allowed.", nEntries, NewEntries);
        throw MaCh3Exception(__FILE__, __LINE__);
      }
      if (NewEntries <= 0) {
        MACH3LOG_ERROR("Entries cannot be below 0, but {} was passed.", NewEntries);
        throw MaCh3Exception(__FILE__, __LINE__);
      }

      if (static_cast<int>(BurnInCut) > NewEntries) {
          MACH3LOG_ERROR("BurnInCut ({}) is larger than NewEntries ({})", BurnInCut, NewEntries);
          throw MaCh3Exception(__FILE__, __LINE__);
      }

      MACH3LOG_INFO("Setting entries to {} from {}.", NewEntries, nEntries);
      MACH3LOG_WARN("This may behave not as expected when using merged multiple chains");
      nEntries = NewEntries;
    }
    /// @brief Set the step cutting by string
    /// @param Cuts string telling cut value
    void SetStepCut(const std::string& Cuts);
    /// @brief Set the step cutting by int
    /// @param Cuts integer telling cut value
    void SetStepCut(const int Cuts);
    /// @brief Check if step cut isn't larger than highest values of step in a chain
    void CheckStepCut() const;

    /// @brief You can set relative to prior or relative to generated. It is advised to use relate to prior
    /// @param PlotOrNot bool controlling plotRelativeToPrior argument
    inline void SetPlotRelativeToPrior(const bool PlotOrNot){plotRelativeToPrior = PlotOrNot; };
    /// @brief Whether to dump all plots into PDF
    inline void SetPrintToPDF(const bool PlotOrNot){printToPDF = PlotOrNot; };
    /// @brief Set whether you want to plot error for parameters which have flat prior
    inline void SetPlotErrorForFlatPrior(const bool PlotOrNot){PlotFlatPrior = PlotOrNot; };
    inline void SetPlotBinValue(const bool PlotOrNot){plotBinValue = PlotOrNot; };
    inline void SetFancyNames(const bool PlotOrNot){FancyPlotNames = PlotOrNot; };
    /// @brief Set whether want to use smoothing for histograms using ROOT algorithm
    inline void SetSmoothing(const bool PlotOrNot){ApplySmoothing = PlotOrNot; };
    /// @brief Code will only plot 2D posteriors if Correlation are larger than defined threshold
    /// @param Threshold This threshold is compared with correlation value
    inline void SetPost2DPlotThreshold(const double Threshold){Post2DPlotThreshold = Threshold; };
    /// @brief Toggle using the FFT-based autocorrelation calculator
    inline void SetUseFFTAutoCorrelation(const bool useFFT){useFFTAutoCorrelation = useFFT; };

    /// @brief Setter related what parameters we want to exclude from analysis, for example if cross-section parameters look like xsec_, then passing "xsec_" will
    /// @param Batches Vector with parameters type names we want to exclude
    inline void SetExcludedTypes(std::vector<std::string> Name){ExcludedTypes = Name; };
    inline void SetExcludedNames(std::vector<std::string> Name){ExcludedNames = Name; };
    inline void SetExcludedGroups(std::vector<std::string> Name){ExcludedGroups = Name; };

    /// @brief Set value of Nbatches used for batched mean, this need to be done earlier as batches are made when reading tree
    /// @param Batches Number of batches, default is 20
    inline void SetnBatches(const int Batches){nBatches = Batches; };
    inline void SetnLags(const int nLags){AutoCorrLag = nLags; };
    
    /// @brief Sett output suffix, this way jobs using the same file will have different names
    inline void SetOutputSuffix(const std::string Suffix){OutputSuffix = Suffix; };
    /// @brief Allow to set addtional cuts based on ROOT TBrowser cut, for to only affect one mass ordering
    inline void SetPosterior1DCut(const std::string Cut){Posterior1DCut = Cut; };

  protected:
    /// @brief Prepare prefit histogram for parameter overlay plot
    inline std::unique_ptr<TH1D> MakePrefit();
    /// @brief prepare output root file and canvas to which we will save EVERYTHING
    inline void MakeOutputFile();
    /// @brief Draw 1D correlations which might be more helpful than looking at huge 2D Corr matrix
    inline void DrawCorrelations1D();
    /// @brief Produces correlation matrix but instead of giving name for each param it only give name for param group
    /// @param CorrMatrix correlation matrix that we are going to plot
    /// @note Inspired by plot in Ewan thesis see https://www.t2k.org/docs/thesis/152/Thesis#page=147
    inline void DrawCorrelationsGroup(const std::unique_ptr<TH2D>& CorrMatrix) const;
    /// @brief CW: Read the input Covariance matrix entries. Get stuff like parameter input errors, names, and so on
    inline void ReadInputCov();
    /// @warning This will no longer be supported in future
    inline void ReadInputCovLegacy();
    /// @brief Read the output MCMC file and find what inputs were used
    inline void FindInputFiles();
    /// @warning This will no longer be supported in future
    inline void FindInputFilesLegacy();
    /// @brief Read the xsec file and get the input central values and errors
    inline void ReadModelFile();
    /// @brief allow loading additional info for example used for oscillation parameters
    virtual void LoadAdditionalInfo() {};
    /// @brief Read the ND cov file and get the input central values and errors
    inline void ReadNDFile();
    /// @brief Read the FD cov file and get the input central values and errors
    inline void ReadFDFile();
    /// @brief Print info like how many params have been loaded etc
    inline void PrintInfo() const;

    /// @brief Scan Input etc.
    inline void ScanInput();
    /// @brief Scan order of params from a different groups
    inline void ScanParameterOrder();
    /// @brief Prepare all objects used for output
    inline void SetupOutput();

    // MCMC Diagnostic
    /// @brief CW: Prepare branches etc. for DiagMCMC
    inline void PrepareDiagMCMC();
    /// @brief Computes the average of each parameter across all MCMC entries. Useful for autocorrelation
    std::vector <double> GetParameterSums();
    /// @brief CW: Draw trace plots of the parameters i.e. parameter vs step
    inline void ParamTraces();
    /// @brief KS: Calculate autocorrelations supports both OpenMP and CUDA :)
    inline void AutoCorrelation();
    /// @brief MJR: Autocorrelation function using FFT algorithm for extra speed
    /// @author Michael Reh
    inline void AutoCorrelation_FFT();
    /// @brief KS: calc Effective Sample Size
    /// @param nLags Should be the same nLags as used in AutoCorrelation()
    /// @param LagL Value of LagL for each dial and each Lag
    ///
    /// This function computes the Effective Sample Size (ESS) using the autocorrelations
    /// calculated by AutoCorrelation(). Ensure that the parameter nLags here matches
    /// the number of lags used in AutoCorrelation() to obtain accurate results.
    /// @cite StanManual
    /// @cite hanson2008mcmc
    /// @cite gabry2024visual
    inline void CalculateESS(const int nLags, const std::vector<std::vector<double>>& LagL);
    /// @brief Get the batched means variance estimation and variable indicating if number of batches is sensible
    /// @cite chakraborty2019estimating
    /// @cite rossetti2024batch
    inline void BatchedAnalysis();
    /// @brief CW: Batched means, literally read from an array and chuck into TH1D
    inline void BatchedMeans();
    /// @brief Geweke Diagnostic based on the methods described by Fang (2014) and Karlsbakk (2011).
    /// @cite Fang2014GewekeDiagnostics
    /// @cite karlsbakk2011
    inline void GewekeDiagnostic();
    /// @brief Acceptance Probability
    inline void AcceptanceProbabilities();
    /// @brief RC: Perform spectral analysis of MCMC
    /// @cite Dunkley:2004sv
    /// @author Richard Calland
    inline void PowerSpectrumAnalysis();

    /// @brief Get TCanvas margins, to be able to reset them if particular function need different margins
    std::vector<double> GetMargins(const std::unique_ptr<TCanvas>& Canv) const;
    /// @brief Set TCanvas margins to specified values
    void SetMargins(std::unique_ptr<TCanvas>& Canv, const std::vector<double>& margins);
    /// @brief Configures a TLine object with the specified style parameters.
    /// @param Line Pointer to the TLine object to modify. Must not be nullptr.
    /// @param Colour The color to set for the line.
    /// @param Width The width of the line.
    /// @param Style The line style (e.g., solid, dashed, etc.).
    void SetTLineStyle(TLine* Line, const Color_t Colour, const Width_t Width, const ELineStyle Style) const;
    /// @brief Configures the style of a TLegend object.
    /// @param Legend Pointer to the TLegend object to modify
    /// @param size The text size to set for the legend
    void SetLegendStyle(TLegend* Legend, const double size) const;

    /// Name of MCMC file
    std::string MCMCFile;
    /// Output file suffix useful when running over same file with different settings
    std::string OutputSuffix;
    /// Covariance matrix file name position
    std::vector<std::vector<std::string>> CovPos;
    /// Covariance matrix name position
    std::vector<std::string> CovNamePos;
    /// Covariance matrix config
    std::vector<YAML::Node> CovConfig;

    /// Main chain storing all steps etc
    TChain *Chain;
    /// BurnIn Cuts
    std::string StepCut;
    /// Cut used when making 1D Posterior distribution
    std::string Posterior1DCut;
    /// KS: Used only for SubOptimality
    unsigned int UpperCut;
    /// Value of burn in cut
    unsigned int BurnInCut;
    /// Number of branches in a TTree
    int nBranches;
    /// KS: For merged chains number of entries will be different from nSteps
    int nEntries;
    /// KS: For merged chains number of entries will be different from nSteps
    int nSteps;
    /// Number of sample PDF objects
    int nSampleHandlers;
    /// Number of covariance objects
    int nParameterHandlers;
    /// Number of all parameters used in the analysis
    int nDraw;
    
    //Name of all branches as well as branches we don't want to include in the analysis
    std::vector<TString> BranchNames;
    std::vector<std::string> ExcludedTypes;
    std::vector<std::string> ExcludedNames;
    std::vector<std::string> ExcludedGroups;

    /// Is the ith parameter varied
    std::vector<bool> IamVaried;
    /// Name of parameters which we are going to analyse
    std::vector<std::vector<TString>> ParamNames;
    /// Parameters central values which we are going to analyse
    std::vector<std::vector<double>>  ParamCentral;
    /// Uncertainty on a single parameter
    std::vector<std::vector<double>>  ParamErrors;
    /// Whether Param has flat prior or not
    std::vector<std::vector<bool>>    ParamFlat;
    /// Number of parameters per type
    std::vector<int> nParam;
    /// Make an enum for which class this parameter belongs to so we don't have to keep string comparing
    std::vector<ParameterEnum> ParamType;
    /// KS: in MCMC output there is order of parameters so for example first goes xsec then nd det etc.
    /// Idea is that this parameter will keep track of it so code is flexible
    std::vector<int> ParamTypeStartPos;
    // KS: For example flux or detector within matrix
    std::vector<std::string> ParameterGroup;

    /// Vector of each systematic
    std::vector<TString> SampleName_v;
    /// Vector of each sample PDF object
    std::vector<TString> SystName_v;
    
    /// Name of output files
    std::string OutputName;
    /// Name of canvas which help to save to the sample pdf
    TString CanvasName;

    /// Whether we plot flat prior or not, we usually provide error even for flat prior params
    bool PlotFlatPrior;
    
    //Even more flags
    /// Whether we plot relative to prior or nominal, in most cases is prior
    bool plotRelativeToPrior;
    /// Sanity check if Postfit is already done to not make several times
    bool MadePostfit;
    /// Will plot all plot to PDF not only to root file
    bool printToPDF;
    /// Whether we want fancy plot names or not
    bool FancyPlotNames;
    /// If true it will print value on each bin of covariance matrix
    bool plotBinValue;
    /// Apply smoothing for 2D histos using root algorithm
    bool ApplySmoothing;
    /// KS: Set Threshold when to plot 2D posterior as by default we get a LOT of plots
    double Post2DPlotThreshold;
    /// MJR: Use FFT-based autocorrelation algorithm (save time & resources)?
    bool useFFTAutoCorrelation;

    std::vector<int> NDSamplesBins;
    std::vector<std::string> NDSamplesNames;

    /// Gaussian fitter
    std::unique_ptr<TF1> Gauss;

    /// The output file
    TFile *OutputFile;
    
    /// Fancy canvas used for our beautiful plots
    std::unique_ptr<TCanvas> Posterior;

    //Vector of best fit points and errors obtained with different methods
    /// Vector with central value for each parameter
    TVectorD *Central_Value;
    /// Vector with mean values using Arithmetic Mean
    TVectorD *Means;
    /// Vector with errors values using RMS
    TVectorD *Errors;
    /// Vector with mean values using Gaussian fit
    TVectorD *Means_Gauss;
    /// Vector with error values using Gaussian fit
    TVectorD *Errors_Gauss;
    /// Vector with mean values using Highest Posterior Density
    TVectorD *Means_HPD;
    /// Vector with error values using Highest Posterior Density
    TVectorD *Errors_HPD;
    /// Vector with positive error (right hand side) values using Highest Posterior Density
    TVectorD *Errors_HPD_Positive;
    /// Vector with negative error (left hand side) values using Highest Posterior Density
    TVectorD *Errors_HPD_Negative;

    /// Posterior Covariance Matrix
    TMatrixDSym *Covariance;
    /// Posterior Correlation Matrix
    TMatrixDSym *Correlation;

    /// Holds 1D Posterior Distributions
    std::vector<TH1D*> hpost;
    /// Holds 2D Posterior Distributions
    std::vector<std::vector<TH2D*>> hpost2D;
    /// Holds violin plot for all dials
    std::unique_ptr<TH2D> hviolin;
    /// Holds prior violin plot for all dials,
    std::unique_ptr<TH2D> hviolin_prior;

    /// Array holding values for all parameters
    M3::float_t** ParStep;
    /// Step number for step, important if chains were merged
    unsigned int* StepNumber;

    /// Number of bins
    int nBins;
    /// Drawrange for SetMaximum
    double DrawRange;
    
    /// MCMC Chain has been cached
    bool CacheMCMC;
    /// Doing MCMC Diagnostic
    bool doDiagMCMC;
    
    //Number of batches and LagL used in MCMC diagnostic
    /// Number of batches for Batched Mean
    int nBatches;
    /// LagL used in AutoCorrelation
    int AutoCorrLag;
    
    /// Values of batched average for every param and batch
    double **BatchedAverages;

    /// Holds the sample values
    double **SampleValues;
    /// Holds the systs values
    double **SystValues;

    /// Holds all accProb
    double *AccProbValues;
    /// Holds all accProb in batches
    double *AccProbBatchedAverages;
    
    /// Whether to apply reweighting weight or not
    bool ReweightPosterior;
    /// Name of branch used for chain reweighting
    std::string ReweightName;
    /// Stores value of weight for each step
    double* WeightValue;

  //Only if GPU is enabled
  #ifdef MaCh3_CUDA
    /// @brief Move stuff to GPU to perform auto correlation calculations there
    void PrepareGPU_AutoCorr(const int nLags, const std::vector<double>& ParamSums, float*& ParStep_cpu,
                             float*& NumeratorSum_cpu, float*& ParamSums_cpu, float*& DenomSum_cpu);
    std::unique_ptr<MCMCProcessorGPU> GPUProcessor;
  #endif
};
