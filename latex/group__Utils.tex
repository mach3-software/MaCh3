\hypertarget{group__Utils}{}\doxysection{Plotting Utility Functions}
\label{group__Utils}\index{Plotting Utility Functions@{Plotting Utility Functions}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
TH1D \mbox{\hyperlink{group__Utils_gaf1329db6e5a742f7dcfa154629c54542}{Ma\+Ch3\+Plotting\+::\+TGraph\+To\+TH1D}} (TGraph graph, std\+::string new\+Name=\char`\"{}\char`\"{}, std\+::string new\+Title=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em This handy little function lets you interpret a TGraph as a TH1D. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \mbox{\hyperlink{group__Utils_gabee3ac13b77811574c1650016e81a229}{Ma\+Ch3\+Plotting\+::\+TGraph\+To\+Vector}} (TGraph graph)
\begin{DoxyCompactList}\small\item\em This handy little function lets you interpret a TGraph as a vector containing the same data. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \mbox{\hyperlink{group__Utils_ga30c29bb2cae29751d106bd93dfeaff81}{Ma\+Ch3\+Plotting\+::\+TGraph\+To\+Vector}} (TGraph2D graph)
\begin{DoxyCompactList}\small\item\em This handy little function lets you interpret a 2d TGraph as a vector containing the same data. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__Utils_gaf1329db6e5a742f7dcfa154629c54542}\label{group__Utils_gaf1329db6e5a742f7dcfa154629c54542}} 
\index{Plotting Utility Functions@{Plotting Utility Functions}!TGraphToTH1D@{TGraphToTH1D}}
\index{TGraphToTH1D@{TGraphToTH1D}!Plotting Utility Functions@{Plotting Utility Functions}}
\doxysubsubsection{\texorpdfstring{TGraphToTH1D()}{TGraphToTH1D()}}
{\footnotesize\ttfamily TH1D Ma\+Ch3\+Plotting\+::\+TGraph\+To\+TH1D (\begin{DoxyParamCaption}\item[{TGraph}]{graph,  }\item[{std\+::string}]{new\+Name,  }\item[{std\+::string}]{new\+Title }\end{DoxyParamCaption})}



This handy little function lets you interpret a TGraph as a TH1D. 

It will go through your provided graph and make a histogram binning by taking the midpoints of all the graph points x values, then fill the histogram with the graphs y values. For the first and last points it will extend the binning out of the graph bounds using the width between the outermost and second outermost points. This can be useful if e.\+g. you want to draw cumulative stacks of LLH scans.


\begin{DoxyParams}{Parameters}
{\em graph} & The graph you want to convert. \\
\hline
{\em new\+Name} & The new name you want to give to the histogram. If not specified, will just use the name of the graph. \\
\hline
{\em new\+Title} & The new title you want to give to the histogram. If not specified, will just use the title of the graph. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{plottingUtils_8cpp_source_l00010}{10}} of file \mbox{\hyperlink{plottingUtils_8cpp_source}{plotting\+Utils.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00011\ \ \ std::string\ name;}
\DoxyCodeLine{00012\ \ \ std::string\ title;}
\DoxyCodeLine{00013\ }
\DoxyCodeLine{00014\ \ \ \textcolor{keywordflow}{if}\ (newName\ ==\ \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{00015\ \ \ \ \ name\ =\ graph.GetName();}
\DoxyCodeLine{00016\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00017\ \ \ \ \ name\ =\ newName;}
\DoxyCodeLine{00018\ }
\DoxyCodeLine{00019\ \ \ \textcolor{keywordflow}{if}\ (newTitle\ ==\ \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{00020\ \ \ \ \ title\ =\ graph.GetTitle();}
\DoxyCodeLine{00021\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00022\ \ \ \ \ title\ =\ newTitle;}
\DoxyCodeLine{00023\ }
\DoxyCodeLine{00024\ \ \ \textcolor{keywordtype}{int}\ nPoints\ =\ graph.GetN();}
\DoxyCodeLine{00025\ \ \ \textcolor{keywordflow}{if}(nPoints\ <\ 2)\{}
\DoxyCodeLine{00026\ \ \ \ \ \mbox{\hyperlink{MaCh3Logger_8h_a61052119a625282d0ec6d4a97adf3ee2}{MACH3LOG\_ERROR}}(\textcolor{stringliteral}{"{}Too\ few\ points\ in\ the\ graph."{}});}
\DoxyCodeLine{00027\ \ \ \ \ \textcolor{keywordflow}{throw}\ \mbox{\hyperlink{classMaCh3Exception}{MaCh3Exception}}(\_\_FILE\_\_,\_\_LINE\_\_);}
\DoxyCodeLine{00028\ \ \ \}}
\DoxyCodeLine{00029\ \ \ std::vector<double>\ pointsX(nPoints);}
\DoxyCodeLine{00030\ \ \ std::vector<double>\ pointsY(nPoints);}
\DoxyCodeLine{00031\ }
\DoxyCodeLine{00032\ \ \ \textcolor{comment}{//\ Get\ the\ points\ out}}
\DoxyCodeLine{00033\ \ \ Double\_t\ x,\ y;}
\DoxyCodeLine{00034\ }
\DoxyCodeLine{00035\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ pointId\ =\ 0;\ pointId\ <\ nPoints;\ pointId++)}
\DoxyCodeLine{00036\ \ \ \{}
\DoxyCodeLine{00037\ \ \ \ \ graph.GetPoint(pointId,\ x,\ y);}
\DoxyCodeLine{00038\ \ \ \ \ pointsX[pointId]\ =\ x;}
\DoxyCodeLine{00039\ \ \ \ \ pointsY[pointId]\ =\ y;}
\DoxyCodeLine{00040\ \ \ \}}
\DoxyCodeLine{00041\ }
\DoxyCodeLine{00042\ \ \ \textcolor{comment}{//\ get\ the\ bin\ edges}}
\DoxyCodeLine{00043\ \ \ std::vector<double>\ binEdges(nPoints\ +\ 1);}
\DoxyCodeLine{00044\ \ \ binEdges[0]\ =\ pointsX[0]\ -\/\ (pointsX[1]\ -\/\ pointsX[0])\ /\ 2.0;}
\DoxyCodeLine{00045\ \ \ binEdges[nPoints]\ =\ pointsX[nPoints\ -\/\ 1]\ +\ (pointsX[nPoints\ -\/\ 1]\ -\/\ pointsX[nPoints\ -\/\ 2])\ /\ 2.0;}
\DoxyCodeLine{00046\ }
\DoxyCodeLine{00047\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ pointId\ =\ 1;\ pointId\ <\ nPoints;\ pointId++)}
\DoxyCodeLine{00048\ \ \ \{}
\DoxyCodeLine{00049\ \ \ \ \ \textcolor{comment}{//\ take\ the\ midpoint\ of\ the\ two\ surrounding\ points}}
\DoxyCodeLine{00050\ \ \ \ \ binEdges[pointId]\ =\ (pointsX[pointId]\ +\ pointsX[pointId\ -\/\ 1])\ /\ 2.0;}
\DoxyCodeLine{00051\ \ \ \}}
\DoxyCodeLine{00052\ }
\DoxyCodeLine{00053\ \ \ TH1D\ retHist\ =\ TH1D(name.c\_str(),\ title.c\_str(),\ nPoints,\ binEdges.data());}
\DoxyCodeLine{00054\ }
\DoxyCodeLine{00055\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ binId\ =\ 0;\ binId\ <\ nPoints;\ binId++)}
\DoxyCodeLine{00056\ \ \ \{}
\DoxyCodeLine{00057\ \ \ \ \ retHist.SetBinContent(binId\ +\ 1,\ pointsY[binId]);}
\DoxyCodeLine{00058\ \ \ \}}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \ \ \textcolor{keywordflow}{return}\ retHist;}
\DoxyCodeLine{00061\ \}}

\end{DoxyCode}
\mbox{\Hypertarget{group__Utils_gabee3ac13b77811574c1650016e81a229}\label{group__Utils_gabee3ac13b77811574c1650016e81a229}} 
\index{Plotting Utility Functions@{Plotting Utility Functions}!TGraphToVector@{TGraphToVector}}
\index{TGraphToVector@{TGraphToVector}!Plotting Utility Functions@{Plotting Utility Functions}}
\doxysubsubsection{\texorpdfstring{TGraphToVector()}{TGraphToVector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::vector$<$ double $>$ $>$ Ma\+Ch3\+Plotting\+::\+TGraph\+To\+Vector (\begin{DoxyParamCaption}\item[{TGraph}]{graph }\end{DoxyParamCaption})}



This handy little function lets you interpret a TGraph as a vector containing the same data. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph you want to convert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of vectors containing the data from the initial graph. The first vector is the x axis, the 2nd the y axis 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{plottingUtils_8cpp_source_l00064}{64}} of file \mbox{\hyperlink{plottingUtils_8cpp_source}{plotting\+Utils.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00065\ }
\DoxyCodeLine{00066\ \ \ \textcolor{keywordtype}{int}\ nPoints\ =\ graph.GetN();}
\DoxyCodeLine{00067\ \ \ std::vector<std::vector<double>>\ ret(2);}
\DoxyCodeLine{00068\ \ \ std::vector<double>\ pointsX(nPoints);}
\DoxyCodeLine{00069\ \ \ std::vector<double>\ pointsY(nPoints);}
\DoxyCodeLine{00070\ }
\DoxyCodeLine{00071\ \ \ \textcolor{comment}{//\ Get\ the\ points\ out}}
\DoxyCodeLine{00072\ \ \ Double\_t\ x,\ y;}
\DoxyCodeLine{00073\ }
\DoxyCodeLine{00074\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ pointId\ =\ 0;\ pointId\ <\ nPoints;\ pointId++)}
\DoxyCodeLine{00075\ \ \ \{}
\DoxyCodeLine{00076\ \ \ \ \ graph.GetPoint(pointId,\ x,\ y);}
\DoxyCodeLine{00077\ \ \ \ \ pointsX[pointId]\ =\ x;}
\DoxyCodeLine{00078\ \ \ \ \ pointsY[pointId]\ =\ y;}
\DoxyCodeLine{00079\ \ \ \}}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ \ \ ret[0]\ =\ pointsX;}
\DoxyCodeLine{00082\ \ \ ret[1]\ =\ pointsY;}
\DoxyCodeLine{00083\ }
\DoxyCodeLine{00084\ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00085\ \}}

\end{DoxyCode}
\mbox{\Hypertarget{group__Utils_ga30c29bb2cae29751d106bd93dfeaff81}\label{group__Utils_ga30c29bb2cae29751d106bd93dfeaff81}} 
\index{Plotting Utility Functions@{Plotting Utility Functions}!TGraphToVector@{TGraphToVector}}
\index{TGraphToVector@{TGraphToVector}!Plotting Utility Functions@{Plotting Utility Functions}}
\doxysubsubsection{\texorpdfstring{TGraphToVector()}{TGraphToVector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::vector$<$ double $>$ $>$ Ma\+Ch3\+Plotting\+::\+TGraph\+To\+Vector (\begin{DoxyParamCaption}\item[{TGraph2D}]{graph }\end{DoxyParamCaption})}



This handy little function lets you interpret a 2d TGraph as a vector containing the same data. 


\begin{DoxyParams}{Parameters}
{\em graph} & The graph you want to convert. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of vectors containing the data from the initial graph. The first vector is the x axis, the 2nd the y axis, the 3rd is the z axis 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{plottingUtils_8cpp_source_l00088}{88}} of file \mbox{\hyperlink{plottingUtils_8cpp_source}{plotting\+Utils.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00088\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00089\ }
\DoxyCodeLine{00090\ \ \ \textcolor{keywordtype}{int}\ nPoints\ =\ graph.GetN();}
\DoxyCodeLine{00091\ \ \ std::vector<std::vector<double>>\ ret(3);}
\DoxyCodeLine{00092\ \ \ std::vector<double>\ pointsX(nPoints);}
\DoxyCodeLine{00093\ \ \ std::vector<double>\ pointsY(nPoints);}
\DoxyCodeLine{00094\ \ \ std::vector<double>\ pointsZ(nPoints);}
\DoxyCodeLine{00095\ }
\DoxyCodeLine{00096\ \ \ \textcolor{comment}{//\ Get\ the\ points\ out}}
\DoxyCodeLine{00097\ \ \ Double\_t\ x,\ y,\ z;}
\DoxyCodeLine{00098\ }
\DoxyCodeLine{00099\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ pointId\ =\ 0;\ pointId\ <\ nPoints;\ pointId++)}
\DoxyCodeLine{00100\ \ \ \{}
\DoxyCodeLine{00101\ \ \ \ \ graph.GetPoint(pointId,\ x,\ y,\ z);}
\DoxyCodeLine{00102\ \ \ \ \ pointsX[pointId]\ =\ x;}
\DoxyCodeLine{00103\ \ \ \ \ pointsY[pointId]\ =\ y;}
\DoxyCodeLine{00104\ \ \ \ \ pointsZ[pointId]\ =\ z;}
\DoxyCodeLine{00105\ \ \ \}}
\DoxyCodeLine{00106\ }
\DoxyCodeLine{00107\ \ \ ret[0]\ =\ pointsX;}
\DoxyCodeLine{00108\ \ \ ret[1]\ =\ pointsY;}
\DoxyCodeLine{00109\ \ \ ret[2]\ =\ pointsZ;}
\DoxyCodeLine{00110\ }
\DoxyCodeLine{00111\ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{00112\ \}}

\end{DoxyCode}
