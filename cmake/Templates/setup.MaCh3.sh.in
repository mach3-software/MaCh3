# TN: This shebang is rather useless, since I guess the user needs to "source" the setup,
# not execute it. Executing it from a different shell than bash would only open bash, run
# the script and close the bash with no changes in the PATHs of the original shell. That is,
# nothing gets set up. If the script is sourced, the shebang is skipped and the script is sourced
# from the original shell (not bash).
# Anyway, I will keep it here, if there is some use to it I am missing.
#!/bin/bash

if ! type add_to_PATH &> /dev/null; then

### Adapted from https://unix.stackexchange.com/questions/4965/keep-duplicates-out-of-path-on-source
add_to_PATH()
{
  for d; do

    d=$( cd -- $d && { pwd -P || pwd; } ) 2>/dev/null  # canonicalize symbolic links
    if [[ -z $d ]]; then continue; fi  # skip nonexistent directory

    if [[ $d == "/usr/bin" || $d == "/usr/bin64" || $d == "/usr/local/bin" || $d == "/usr/local/bin64" ]]; then
      case ":$PATH:" in
        *":$d:"*) :;;
        *) export PATH=$PATH:$d;;
      esac
    else
      case ":$PATH:" in
        *":$d:"*) :;;
        *) export PATH=$d:$PATH;;
      esac
    fi
  done
}

fi

if ! type add_to_LD_LIBRARY_PATH &> /dev/null; then

add_to_LD_LIBRARY_PATH()
{
  for d; do

    d=$( cd -- $d && { pwd -P || pwd; } ) 2>/dev/null  # canonicalize symbolic links
    if [[ -z $d ]]; then continue; fi  # skip nonexistent directory

    if [[ $d == "/usr/bin" || $d == "/usr/bin64" || $d == "/usr/local/bin" || $d == "/usr/local/bin64" ]]; then
      case ":$LD_LIBRARY_PATH:" in
        *":$d:"*) :;;
        *) export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$d;;
      esac
    else
      case ":$LD_LIBRARY_PATH:" in
        *":$d:"*) :;;
        *) export LD_LIBRARY_PATH=$d:$LD_LIBRARY_PATH;;
      esac
    fi
  done
}

fi


if ! type add_to_PYTHONPATH &> /dev/null; then

### Adapted from ^^
add_to_PYTHONPATH()
{
  for d; do

    d=$( cd -- $d && { pwd -P || pwd; } ) 2>/dev/null  # canonicalize symbolic links
    if [[ -z $d ]]; then continue; fi  # skip nonexistent directory

    if [[ $d == "/usr/bin" || $d == "/usr/bin64" || $d == "/usr/local/bin" || $d == "/usr/local/bin64" ]]; then
      case ":$PYTHONPATH:" in
        *":$d:"*) :;;
        *) export PYTHONPATH=$PYTHONPATH:$d;;
      esac
    else
      case ":$PYTHONPATH:" in
        *":$d:"*) :;;
        *) export PYTHONPATH=$d:$PYTHONPATH;;
      esac
    fi
  done
}

fi

if ! type add_to_DYLD_LIBRARY_PATH &> /dev/null; then

function add_to_DYLD_LIBRARY_PATH () {
  for d; do

    d=$(cd -- "$d" && { pwd -P || pwd; }) 2>/dev/null  # canonicalize symbolic links
    if [ -z "$d" ]; then continue; fi  # skip nonexistent directory

    if [[ "$d" == "/usr/lib" ]] || [[ "$d" == "/usr/lib64" ]] || [[ "$d" == "/usr/local/lib" ]] || [[ "$d" == "/usr/local/lib64" ]]; then
      case ":$DYLD_LIBRARY_PATH:" in
        *":$d:"*) :;;
        *) export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:$d;;
      esac
    else
      case ":$DYLD_LIBRARY_PATH:" in
        *":$d:"*) :;;
        *) export DYLD_LIBRARY_PATH=$d:$DYLD_LIBRARY_PATH;;
      esac
    fi
  done
}

fi

if [ -n "$BASH_VERSION" ]; then
  SCRIPT_PATH="${BASH_SOURCE[0]}"
elif [ -n "$ZSH_VERSION" ]; then
  SCRIPT_PATH="${(%):-%x}"
else
  echo "Unsupported shell"
  return 1
fi

#if it was sourced as . setup.sh then you can't scrub off the end... assume that
#we are in the correct directory.
if ! echo "${SCRIPT_PATH}" | grep "/" --silent; then
  SETUPDIR=$(readlink -f ${PWD}/..)
else
  SETUPDIR=$(readlink -f ${SCRIPT_PATH%/*}/..)
fi

export MaCh3_ROOT=${SETUPDIR}
export MaCh3_VERSION=@MaCh3_VERSION@

add_to_PATH ${MaCh3_ROOT}/bin

if [[ "$(uname)" == "Darwin" ]]; then # macOS
  add_to_DYLD_LIBRARY_PATH ${MaCh3_ROOT}/lib
  if [ -d "${MaCh3_ROOT}/lib64" ]; then
    add_to_DYLD_LIBRARY_PATH ${MaCh3_ROOT}/lib64
  fi
else
  add_to_LD_LIBRARY_PATH ${MaCh3_ROOT}/lib
  if [ -d "${MaCh3_ROOT}/lib64" ]; then
    add_to_LD_LIBRARY_PATH ${MaCh3_ROOT}/lib64
  fi
fi

if [[ -f "${MaCh3_ROOT}/bin/setup.NuOscillator.sh" ]]; then
  echo "Sourcing NuOscillator"
  source "${MaCh3_ROOT}/bin/setup.NuOscillator.sh"
fi

if test -d ${MaCh3_ROOT}/pyMaCh3; then
  add_to_PYTHONPATH ${MaCh3_ROOT}
fi

unset SCRIPT_PATH
