  /// @file Definitions.dox
  /// @brief Stores definitions used throughout MaCh3 doxygen
  /// @details by having all core definitions here it allows to easily find necessary definition and avoid double defining them
  /// @author Kamil Skwarczynski

  /// @defgroup FittingAlgorithms Fitting Algorithms
  /// @brief Available in MaCh3 fitting algorithms.
  ///
  /// # Introduction
  /// MaCh3 provides multiple fitting strategies that fall into two main categories:
  /// Markov Chain Monte Carlo samplers and likelihood minimisation algorithms.
  ///
  /// -----------------------------------------------------------------------------
  /// # Markov Chain Monte Carlo (MCMC)
  /// These algorithms explore parameter space by stochastic sampling of the posterior.
  /// They are primarily used for full Bayesian inference and high-dimensional problems.
  ///
  /// Implemented methods:
  /// - **MR2T2** — Metropolis–Rosenbluth–Rosenbluth–Teller–Teller sampler.
  /// - **DelayedMR2T2** — Extension including delayed rejection to improve
  ///   sampling efficiency and acceptance in difficult likelihood surfaces.
  ///
  /// -----------------------------------------------------------------------------
  /// # Likelihood Minimizers
  /// These algorithms deterministically minimise the negative log-likelihood to
  /// obtain a best-fit point. They are typically much faster than MCMC and are
  /// useful for diagnostics, validation, and systematic scans.
  ///
  /// Implemented methods:
  /// - **MinuitFit** — Gradient-based minimiser.
  /// - **PSO (Particle Swarm Optimisation)** — Global optimisation using a swarm
  ///   of walkers to locate the likelihood minimum.
  ///
  /// # Factory Method
  /// A factory method is implemented to select the algorithm from the
  /// configuration file instead of hard-coding it.
  ///
  /// Example configuration:
  /// @code{.yaml}
  /// General:
  ///   FittingAlgorithm: "MCMC"
  /// @endcode
  ///
  /// or
  ///
  /// @code{.yaml}
  /// General:
  ///   FittingAlgorithm: "PSO"
  /// @endcode
  ///
  /// This allows switching algorithms without recompilation.


  /// @defgroup CoreClasses Core Classes
  /// @brief Core classes of MaCh3 Software
  /// @details These classes form the core of the MaCh3 framework and provide the fundamental
  /// interfaces and base implementations used throughout the analysis chain.

  /// @namespace M3
  /// @brief Main namespace for MaCh3 software



  /// @defgroup MaCh3Plotting MaCh3 Plotting
  /// @brief Flexible, experiment-agnostic plotting utilities for MaCh3.
  ///
  /// The goal with MaCh3s plotting library is to be as flexible as possible and to abstract away all of the most annoying parts about plot making
  /// like reading in the data from fitter output files and keeping track of parameter names across different fitters,
  /// while allowing the user as much freedom as possible when it comes plot style and formatting.
  ///
  /// The plotting Library consists primarily of 3 main manager classes:
  /// - @ref MaCh3Plotting::PlottingManager : This controls the high level stuff. It deals with application level options, command line options,
  /// and holds references to the other managers. This is the main class you should interact with on the user level.
  /// - @ref MaCh3Plotting::InputManager    : This deals with the details of how input files (the outputs of the fitters) should be read and stored. This should be accessed via `<Plotting Manager Instance>.input()`.
  /// - @ref MaCh3Plotting::StyleManager    : This provides some helpful utilities for creating plots.
  /// This should be accessed via `<Plotting Manager Instance>.style()`.
  ///
  /// ---------------------------------------------------------------------------
  /// # Manager Classes
  ///
  /// ## Introduction
  ///
  /// The goal with MaCh3s plotting library is to be as flexible as possible and to
  /// abstract away all of the most annoying parts about plot making like reading in
  /// the data from fitter output files and keeping track of parameter names across
  /// different fitters, while allowing the user as much freedom as possible when it
  /// comes plot style and formatting.
  ///
  /// The plotting Library consists primarily of 3 main manager classes:
  ///
  /// - @ref MaCh3Plotting::PlottingManager
  ///   This controls the high level stuff. It deals with application level options,
  ///   command line options, and holds references to the other managers. This is the
  ///   main class you should interact with on the user level.
  ///
  /// - @ref MaCh3Plotting::InputManager
  ///   This deals with the details of how input files (the outputs of the fitters)
  ///   should be read and stored. This should be accessed via
  ///   `<Plotting Manager Instance>.input()`.
  ///
  /// - @ref MaCh3Plotting::StyleManager
  ///   This provides some helpful utilities for creating plots. This should be
  ///   accessed via `<Plotting Manager Instance>.style()`./// @section config_files Config Files
  ///
  /// In order to achieve a high level of flexibility, MaCh3s plotting library makes
  /// heavy use of config files so that the behavior of the code can be adapted easily
  /// to individual experiments without having to totally reinvent the wheel and rewrite
  /// large amounts of boilerplate code. In line with the rest of MaCh3, the plotting
  /// library uses <a href="https://yaml.org/spec/1.2.2/">YAML</a> to specify its config
  /// files. Each of the manager classes above has a corresponding config file to control
  /// its functionality. The format of these config files are detailed below.
  ///
  /// ## Plotting Config
  ///
  /// This is the highest level config file and corresponds to the behavior of the
  /// Plotting Manager. It should be used to control high level variables like where
  /// to find other config files and various options for the plotting applications.
  /// This config acts as a sort of fixed reference point for the plotting library
  /// and so it's location is semi-hardcoded using the $MACH3 environment variable.
  /// In your experiment specific MaCh3 repository which is built against this MaCh3
  /// core repository, you should define a plotting directory which contains the
  /// config file "PlottingConfig.yaml":
  ///
  /// @code
  /// {MACH3}/plotting/PlottingConfig.yaml
  /// @endcode
  ///
  /// You can find an example of such a config in this repository
  /// <a href="https://github.com/mach3-software/MaCh3/plotting/PlottingConfig.yaml">here</a>.
  ///
  /// The most important options are the ones under `ManagerOptions`:
  ///
  /// @code
  /// ManagerOptions:
  ///     translationConfig: ""
  ///     styleConfig: ""
  /// @endcode
  ///
  /// These tell the plotting manager where to find the other config files that are
  /// needed. `translationConfig` tells the manager where to find the translation
  /// config and `styleConfig` where to find the style config. These should be paths
  /// relative to the `MACH3` environment variable e.g. if your MaCh3 directory
  /// contained your configs in a subdirectory called `Cool-Configs` then it would
  /// look something like:
  ///
  /// @code
  /// ${MaCh3}/..
  /// ${MaCh3}/Cool-Configs/Cool-Translation-Config.yaml
  /// ${MaCh3}/Cool-Configs/Cool-Style-Config.yaml
  /// ${MaCh3}/..
  /// @endcode
  ///
  /// and your config options would look like:
  ///
  /// @code
  /// ManagerOptions:
  ///     translationConfig: "Cool-Configs/Cool-Translation-Config.yaml"
  ///     styleConfig: "Cool-Configs/Cool-Style-Config.yaml"
  /// @endcode
  ///
  /// If the options are left blank as they are above then when running the plotting
  /// code they will default to
  ///
  /// @code
  /// translationConfig: "${MACH3}/plotting/universalTranslator.yaml"
  /// styleConfig: "${MACH3}/plotting/StyleConfig.yaml"
  /// @endcode
  ///
  /// Additionally, this config file contains options specific to each of the
  /// applications described below. They are described in more detail in that section
  /// but the general pattern they follow is
  ///
  /// @code
  /// {ApplicationName}:
  ///     {Option1}: <value>
  ///     {Option2}: <value>
  ///     ...
  /// @endcode
  ///
  /// ## Translation Config
  ///
  /// This config defines the behaviour of the MaCh3Plotting::InputManager. It is used to define
  /// the output format of files from different fitters, and the parameters and
  /// samples that exist within the analysis, and what they are called in different
  /// fitters. This means that you can easily plot and compare files from different
  /// fitters without having to worry about the nitty gritty details of how to read
  /// from each specific file type and can focus on making beautiful plots! The
  /// components which are defined in this config are described below and you can
  /// find an example of such a config
  /// <a href="https://github.com/mach3-software/MaCh3Tutorial/plotting/UniversalTranslator.yaml">here</a>.
  ///
  /// ## Fitter Specification
  ///
  /// In this section of the config file we specify what the output of each fitter
  /// we are interested in looks like so that the plotting code knows where to look
  /// for different outputs. We start this section in typical yaml style with
  ///
  /// @code
  /// FitterSpec:
  /// @endcode
  ///
  /// Now we declare the names of fitters the plotting code should be aware of
  ///
  /// @code
  ///     fitters: ["FITTER_1", "FITTER_2"]
  /// @endcode
  ///
  /// Now for each fitter specified we give some details. For each fitter declared
  /// in `fitters: [blabla]` you need to now include a yaml node like
  ///
  /// @code
  ///     FITTER_1:
  ///         ....
  ///
  ///     FITTER_2:
  ///         ...
  /// @endcode
  ///
  /// Under each of these headers you must now give details.
  ///
  /// ## LLH Scan
  ///
  /// Let's start with LLH scan information.
  ///
  /// You must specify the `LLHObjectType`. This is the type of root object that the
  /// plotter should expect to find in the output file. i.e. how this fitter stores
  /// their LLH scans. This can at present be either TH1D or TGraph. For MaCh3, TH1D
  /// is typically used so we would have
  ///
  /// @code
  ///         LLHObjectType: "TH1D"
  /// @endcode
  ///
  /// Now we specify where to look for the scans for each type of LLH scan (sample,
  /// penalty, and total). Each of these gets its own header and the locations are
  /// specified using the location strings described in more detail elsewhere. This
  /// may look something like
  ///
  /// @code
  ///         ## tell the code where to find likelihood scans for sample, penalty and total likelihood
  ///         sample_LLH:
  ///             location: ["likelihood_scans/Sample_LLH/{PARAMETER}_sam"]
  ///
  ///         penalty_LLH:
  ///             location: ["likelihood_scans/Penalty_LLH:{PARAMETER}_pen"]
  ///
  ///         total_LLH:
  ///             location:
  ///             [
  ///                 "likelihood_scans/Total_LLH_DIR_1:{PARAMETER}_tot",
  ///                 "likelihood_scans/Total_LLH_DIR_2:{PARAMETER}_tot",
  ///             ]
  /// @endcode
  ///
  /// We often also like to make likelihood scans broken down by sample. Here we can
  /// also tell the code where to find these per-sample likelihood scans. This might
  /// look something like
  ///
  /// @code
  ///         bySample_LLH:
  ///             location:
  ///             [
  ///                 "{SAMPLE}_LLH:{PARAMETER}{SAMPLE}",
  ///             ]
  /// @endcode
  ///
  /// ## MCMC
  ///
  /// We can now also specify where to look for things relating to the MCMC posteriors.
  ///
  /// under the `1dPosteriors` heading we can specify the location to look for one
  /// dimensional posterior objects that have been produced from a raw chain using
  /// the MCMCProcessor. For example
  ///
  /// @code
  ///         1dPosteriors:
  ///             location: [
  ///                 "Post_TH1Ds:{PARAMETER}",
  ///             ]
  /// @endcode
  ///
  /// We can also specify where to look for the TTree containing the raw MCMC steps
  /// e.g.
  ///
  /// @code
  ///         MCMCsteps:
  ///             location: [
  ///                 "posteriors",
  ///             ]
  /// @endcode
  ///
  /// Note that the way that these are found is different to most of the other
  /// objects. This will use the MCMCProcessor to find the names of the branches in
  /// the posterior tree. You as a user do not need to worry about this detail but
  /// you should be aware that this use of the MCMCProcessor means that the
  /// `MCMCsteps` option is only usable for MaCh3 based fitters and you will need to
  /// have access to the yaml configs that were used initially
  ///
  ///
  /// ## Parameter Specification
  ///
  /// Another important part of the translation config is to define the parameters
  /// that are modelled in the experiment. This section of the yaml is imaginatively
  /// marked with the `Parameters` header:
  ///
  /// @code
  /// Parameters:
  /// @endcode
  ///
  /// The first step is to define the master list of all of the parameters that the
  /// plotting library should be aware of, this is defined using the `Parameters`
  /// variable. An example of this could look something like
  ///
  /// @code
  ///     Parameters:
  ///     [
  ///         "Norm_Param_0",
  ///         "Norm_Param_1",
  ///         "Norm_Param_2",
  ///
  ///         "Spline_Param_0",
  ///         "Spline_Param_1",
  ///
  ///         "Func_Param_0",
  ///         "Func_Param_1",
  ///         "Func_Param_2",
  ///         "Func_Param_3",
  ///
  ///         "sin2th_12",
  ///         "sin2th_23",
  ///         "sin2th_13",
  ///
  ///         "delm2_12",
  ///         "delm2_23",
  ///
  ///         "delta_cp"
  ///     ]
  /// @endcode
  ///
  /// Note that the names specified here are internal to the plotting library and
  /// do not need to correspond to the ones used in other parts of MaCh3 (although
  /// if they do it makes things a bit easier). These are simply labels used to
  /// uniquely identify the parameters across all files and fitters, as well as
  /// within the config files.
  ///
  /// ## Parameter Specific Options
  ///
  /// We can then also specify options specific to each parameter. The options exist
  /// under headings which should match the labels specified in the list above e.g.
  ///
  /// @code
  ///     Norm_Param_0:
  ///
  ///         ## We can specify "tags" to apply to a parameter
  ///         ## This allows you to later on in your plotting scripts get, for example, all parameters which have the tag "pion"
  ///         ## and plot them together, or all parameters with both the tags "pion" and "FSI"
  ///         tags: ["xsec", "FSI", "pion"]
  ///
  ///         ## We can also specify options for this parameter that are specific to each fitter.
  ///         FITTER_2:
  ///             ## In particular we can specify specific names for this parameter in the different fitters
  ///             ## for different types of object.
  ///             LLH: "XSEC-PARAMETER-1"
  ///             PostFit: "PARAMETER-1"
  ///
  ///             ## We can also provide a post fit error location for this parameter which will
  ///             ## override the more general locations specified earlier for this fitter.
  ///             ## This can be useful if e.g. the parameter appears in more than one of the possible post fit error
  ///             ## TH1Ds. The code doesn't like this and so the override will break the degeneracy.
  ///             postFitLoc: ["errors/Cross-Section Systematics Group 2/values/postFitErrors"]
  ///
  /// @endcode
  ///
  /// If no fitter specific names are specified for a parameter then the name will
  /// default to the label in the list above. Hence why it is useful to use the
  /// regular MaCh3 names for those.
  /// ## Sample Specification
  ///
  /// We must also do the same for the samples that exist in the fitter. The format
  /// for doing this is essentially the same as for the parameters as described
  /// above. An example of this might look like
  ///
  /// @code
  /// Samples:
  ///
  ///     ## Here we define the master list of all the available samples
  ///     Samples:
  ///     [
  ///         "SAMPLE_1",
  ///         "SAMPLE_2",
  ///         "SAMPLE_3",
  ///     ]
  ///
  ///     ## now we can specify particular overrides for each parameter for different fitters
  ///     ## For example, lets assume that FITTER_1 uses the same names that are laid out in the list above
  ///     ## but FITTER_2 uses a slightly different naming convention
  ///     SAMPLE_1:
  ///         FITTER_1:
  ///
  ///         FITTER_2:
  ///             ## this is the name of the sample when dealing with LLH scans
  ///             ## currently this is the only one that matters, however in future it might be useful
  ///             ## to also be able to specify this for different file types, hence why LLH is specified
  ///             ## and not just something general
  ///             LLH: "Sample-1"
  ///
  ///         ## We can specify "tags" to apply to a sample
  ///         ## This allows you to later on in your plotting scripts get, for example, all the samples which, for example,
  ///         ## are related to some particular sub-detector by adding a tag for that detector
  ///         ## Or to samples which correspond to a particular tagged particle
  ///         tags: ["subDet1", "particleTag"]
  /// @endcode
  ///
  /// ## Location Strings
  ///
  /// The translation config makes use of a custom location specifier format which
  /// we will describe here.
  ///
  /// Generally speaking multiple locations can be specified for each object type
  /// by using a list in the config file like
  ///
  /// @code
  /// location: [
  ///     "locationString1",
  ///     "locationString2",
  ///     "locationString3",
  ///     ...
  /// @endcode
  ///
  /// Each specified location will be checked when looking for objects, which can
  /// be very useful e.g. if a fitter saves different parameter types in different
  /// locations.
  ///
  /// There are two types of location strings that can be specified. The first is
  /// the simplest case where you simply specify the exact location of an object
  /// with something like
  ///
  /// @code
  /// location: ["path\to\objects\{PARAMETER}"]
  /// @endcode
  ///
  /// (See Special Tokens below on how to use tokens like `{PARAMETER}`.)
  /// This will look for objects at that specific location with no flexibility.
  /// This has the advantage of being slightly faster as only one location needs to
  /// be checked per object. But sometimes this is not flexible enough and a slightly
  /// broader search is needed. This brings us to the second option in which the
  /// directory and object names can be specified separately by breaking up the
  /// string using `:` as a delimiter like
  ///
  /// @code
  /// location: ["path\to\objects:{PARAMETER}"]
  /// @endcode
  ///
  /// In this case the TDirectory `path\to\objects` will be loaded. Then the
  /// parameter {PARAMETER} will be searched for inside this directory by trying to
  /// match the expanded {PARAMETER} to the end of the object names in the directory.
  /// This can be useful if for example some unknown string like a parameter ID gets
  /// prepended to the names of objects when saving, so that the TDirectory looks
  /// something like:
  ///
  /// @code
  /// path\to\objects
  ///     flux1_parameter_1
  ///     flux2_parameter_2
  ///     xsec1_parameter_3
  ///     xsec2_parameter_4
  /// @endcode
  ///
  /// Having to keep track of the fluxA, xsecB labels and updating the fitter
  /// specific parameter names manually would be incredibly tedious and not very
  /// sustainable as they are liable to change as more parameters of different types
  /// are added. Instead by specifying the location
  /// `path\to\objects:{PARAMETER}`, these parameters would be found correctly
  /// without having to worry about these additional labels.
  ///
  /// (NB: This approach will very likely change to become more flexible in the
  /// future. As it stands it is only able to deal with cases where the end of the
  /// parameter name matches, this isn't very flexible. It would likely be a lot
  /// better to use regex or something like that to be able to specify more general
  /// cases with wildcards. regex is likely a good approach since root has built in
  /// functionality for matching these to object names.)
  ///
  /// ## Special Tokens
  ///
  /// There are a number of special tokens that can be used when specifying a
  /// location. These tokens, which take the form `{SOME_LABEL}` will be replaced
  /// in the code when searching for a particular object in the input file.
  /// Currently the following tokens exist:
  ///
  /// - `{PARAMETER}` - This will be replaced with the fitter specific name of the
  ///   parameter currently being looked for. e.g. if you specify the location
  ///   string "path_to\{PARAMETER}_LLH" for an LLH scan then when the code is
  ///   looking for LLH scans for parameter_1 the location will be expanded to
  ///   "path_to\parameter_1_LLH"
  ///
  /// - `{SAMPLE}` - This will be replaced by the fitter specific name of the sample
  ///   currently being looked for. e.g. if you specify the location string
  ///   "path_to\{SAMPLE}\{PARAMETER}_LLH" for the sample specific LLH scans then
  ///   when looking for the scan of parameter_2 for sample sample_1 the location
  ///   will be expanded to "path_to\sample_1\parameter_2_LLH"
  ///
  /// - `{PARAMETER2}` - This can be used for cases where an object is labelled by
  ///   2 parameters, e.g. 2D LLH scans, or 2D posterior distributions. If you
  ///   specified the location string
  ///   "path_to\{PARAMETER}_{PARAMETER2}_2D_object" then when looking for a 2D
  ///   object for parameter_1 and parameter_45 then it would be expanded to
  ///   "path_to\parameter_1_parameter_45_2D_object". (Note that currently no 2d
  ///   objects are actually looked for but this could be useful in the future)
  ///
  ///
  /// ## Style Config
  ///
  /// This config corresponds to the behavior of the MaCh3Plotting::StyleManager. Here you can
  /// specify options relating to the style of your plots.
  ///
  /// ### Colour Palettes
  ///
  /// You can specify colour palettes in the same style as root as follows:
  ///
  /// @code
  /// ColorPallettes: # <- Tells yaml that the following are colour palettes
  ///
  ///   RedWhiteBlue: # <- The name of this palette
  ///   [
  ///       ## blue to white to red gradient, usually used for cov matrices and sigma vatiations
  ///       [255.0], ## Number of colours
  ///       [ 0.00, 0.25, 0.50, 0.75, 1.00 ], ## stops
  ///       [ 0.00, 0.25, 1.00, 1.00, 0.50 ], ## Reds
  ///       [ 0.00, 0.25, 1.00, 0.25, 0.00 ], ## greens
  ///       [ 0.50, 1.00, 1.00, 0.25, 0.00 ], ## blues
  ///   ]
  ///
  ///   AnotherPalette:
  ///   ...
  /// @endcode
  ///
  /// Which will give you a red-white-blue palette. The palettes you specify here
  /// can then be used in your plotting scripts by referencing the name set here
  /// using, for example,
  /// `<plotting manager instance>.style()->SetPalette("RedWhiteBlue")`.
  ///
  /// ### Pretty Names
  ///
  /// You can define fancy names to use in place of the parameter and sample tags
  /// defined in the translation config. You can even use latex here for added
  /// fanciness. This should look something like:
  ///
  /// @code
  ///     ## first nice names for parameters
  ///     parameters:
  ///
  ///         XSEC_PAR_1: "{#phi}ancy xsec parameter: 1"
  ///         XSEC_PAR_2: "{#phi}ancy xsec parameter: 2"
  ///         XSEC_PAR_3: "{#phi}ancy xsec parameter: 3"
  ///
  ///         DETSYST_PAR_1: "{#Delta}etector systematic 1"
  ///         DETSYST_PAR_2: "{#Delta}etector systematic 2"
  ///
  ///         FLUX_PAR_1: "{#Phi}_1"
  ///         FLUX_PAR_2: "{#Phi}_2"
  ///
  ///         OSC_PAR_1: "{#Delta}m^2_{23}"
  ///         OSC_PAR_2: "{#delta}_{CP}"
  ///         OSC_PAR_3: "{#theta}_{14}"
  ///
  ///     ## now same for samples
  ///     samples:
  ///
  ///         SAMPLE_1: "sample 1"
  ///         SAMPLE_2: "sample 2"
  ///         SAMPLE_3: "sample 3"
  ///
  /// @endcode
  ///
  ///
  /// # Usage
  ///
  /// In this section we will cover the general usage of the plotting library. The
  /// Standard Apps sections covers the usage of the apps that are used to make the
  /// "standard" MaCh3 plots that often appear in tech notes and papers. If you are
  /// not interested in doing anything fancy and simply want to reproduce some of
  /// these standard plots for comparisons and validations against a previous
  /// result, then you can just use these.
  ///
  /// If you are interested in doing more advanced things and need a more custom
  /// solution, then see the Custom Plotting Scripts section for information on
  /// using the plotting utilities in your own scripts.
  ///
  /// In this section we will cover the general usage of the plotting library. The
  /// Standard Apps sections covers the usage of the apps that are used to make the
  /// "standard" MaCh3 plots that often appear in tech notes and papers. If you are
  /// not interested in doing anything fancy and simply want to reproduce some of
  /// these standard plots for comparisons and validations against a previous
  /// result, then you can just use these.
  ///
  /// If you are interested in doing more advanced things and need a more custom
  /// solution, then see the Custom Plotting Scripts section for information on
  /// using the plotting utilities in your own scripts.
  ///
  ///
  /// ## Command Line Interface
  ///
  /// Through the use of the MaCh3Plotting::PlottingManager class, we are able to define a common
  /// command line interface across all plotting apps (which you can also use in
  /// your own custom plotting apps, and even python scripts!). The general usage
  /// pattern looks like
  ///
  /// @code
  /// <Plotting App> [Optional parameters] <Input File 1> <Input File 2> ...
  /// @endcode
  ///
  /// where the optional parameters are detailed in Available Options.
  ///
  /// In the case of a python script this simply becomes
  ///
  /// @code
  /// python <Plotting Script>.py [Optional parameters] <Input File 1> <Input File 2>
  /// @endcode
  ///
  ///
  /// ## Available Options
  ///
  /// There are a number of pre-defined general options which can be specified when
  /// plotting. These are described below:
  ///
  /// @code
  ///     -r overlay ratio plots
  ///
  ///     -s also make plots split by sample contribution, to use this option, the LLH scan must have been run with the option `LLH_SCAN_BY_SAMPLE = true` in the config file
  ///
  ///     -g draw a grid on the plots
  ///
  ///     -l a string specifying the labels for each scan to plot in the legent. this should be a string of labels separated by semi colons, e.g.: -`l "label1;label2;label3"`
  ///
  ///     -o the name of the output pdf
  ///
  ///     -d a string specifying additional drawing options to pass to the histogram draw calls, e.g. `-d "C"` will plot smooth curves through the histogram bins. See https://root.cern/doc/master/classTHistPainter.html#HP01a for possible options.
  /// @endcode
  ///
  /// Note that not all of these options are valid for all plotting purposes. For
  /// example, the `-s` option only makes sense for plotting objects which can be
  /// split by sample, this does not apply for example to plotting post fit errors.
  /// Currently specifying an invalid option will simply not have any effect on the
  /// produced plots however in future it would likely be useful to produce some
  /// sort of error or warning.
  ///
  ///
  /// ## Standard Apps
  ///
  /// ### PlotLLH
  ///
  /// Plots log likelihood scans which have been made by scanning each parameter
  /// through its prior range and calculating the likelihood. can take any number
  /// of LLH scans as input, will use the first one as a baseline when making e.g.
  /// ratio plots.
  ///
  /// ### GetPostFitParamPlots
  ///
  /// This will plot output from @ref ProcessMCMC for nice plots which can go to TN.
  /// Bits are hardcoded to make plots nicer users should be careful when using the
  /// non-conventional xsec model. If Violin plot was produced in `ProcessMCMC` you will get fancy plots
  /// here as well.
  ///
  ///
  /// ### MatrixPlotter
  ///
  /// Requires output from @ref ProcessMCMC (must be run with `PlotCorr`).
  /// Allows plotting of submatrices and any combination of parameters.
  ///
  /// ### PredictivePlotting
  ///
  /// Allows comparison of prior/posterior predictive distributions.
  /// Requires output from running @ref PredictiveThrower::RunPredictiveAnalysis RunPredictiveAnalysis.
  ///
  /// ### PlotSigmaVariation
  ///
  /// Produces sigma variation comparisons.
  /// Requires output from running @ref FitterBase::RunSigmaVar RunSigmaVar.
  ///
  ///
  /// ## Custom Plotting Scripts
  ///
  /// If you want more flexibility with your plotting, you can use the manager
  /// classes in your own plotting scripts so that you have all the benefits of
  /// MaCh3s plotting library (Generalised input reading, unified command line
  /// interface, configurability, a number of general plotting utility functions)
  /// but with total freedom of how to actually make plots. In general this is as
  /// easy as including the MaCh3Plotting::PlottingManager in your script, initialising it with
  /// the command line inputs, and then you're good to go! This section will give
  /// some more details on how to do this, along with some examples using fitter
  /// outputs that you can generate by following the MaCh3 Tutorial.
  ///
  /// # Python Interface
  ///
  /// MaCh3 also provides a Python interface for plotting and analyzing MCMC/fitter outputs.
  /// This allows full access to the plotting utilities from Python scripts, including
  /// command line input parsing, PDF export, and custom styling.
  ///
  /// ## Installation
  ///
  /// The plotting library comes with a Python interface. See the
  /// [MaCh3 Python interface README](https://github.com/mach3-software/MaCh3/blob/develop/README.md#python)
  /// for installation details.
  ///
  /// ## Basic Usage
  ///
  /// Once installed, you can import the plotting submodule as follows:
  ///
  /// ```python
  /// from pyMaCh3 import plotting
  /// ```
  ///
  /// ### Example: Plotting Likelihood Scans
  ///
  /// The following example demonstrates how to plot LLH scans for all known parameters
  /// and save them to a PDF:
  ///
  /// @code{.python}
  /// from pyMaCh3 import plotting
  /// import matplotlib.backends.backend_pdf
  /// from matplotlib import pyplot as plt
  /// import sys
  ///
  /// # Create an instance of the PlottingManager
  /// man = plotting.PlottingManager()
  ///
  /// # Parse command line inputs passed to the script
  /// man.parse_inputs(sys.argv)
  ///
  /// # Open a PDF file to save the generated plots
  /// pdf = matplotlib.backends.backend_pdf.PdfPages("LLH-scans.pdf")
  ///
  /// # Loop through all known parameters and plot their likelihood scans
  /// for i, param in enumerate(man.input().get_known_parameters()):
  ///     fig = plt.figure()
  ///     plt.title(man.style().prettify_parameter_name(param))
  ///
  ///     for file_id in range(man.input().get_n_input_files()):
  ///         llh_scan = man.input().get_llh_scan(file_id, param, "sample")
  ///         plt.plot(llh_scan[0], llh_scan[1])
  ///
  ///     pdf.savefig(fig)
  ///
  /// pdf.close()
  /// @endcode
  ///
  /// This workflow gives you access to all plotting utilities from Python, while
  /// preserving the general input handling, styling, and convenience provided
  /// by the MaCh3 library.


  /// @defgroup MaCh3DiagnosticProcessing MaCh3 Diagnostic & Processing
  /// @brief Tools used for diagnostic MCMC and general MCMC processing
  ///
  /// # Diagnostic Applications
  ///
  /// <b>@ref ProcessMCMC.cpp "ProcessMCMC"</b>
  /// The main application for analysing the ND280 chain. It prints posterior
  /// distributions after the burn-in cut and allows comparison of two or three
  /// different chains. Several options can be configured directly in the app,
  /// such as selection, burn-in cut, and whether to plot xsec+flux or only flux.
  ///
  /// Additional functionality includes:
  /// <ol>
  ///   <li>Produce a covariance matrix with multithreading (RAM intensive due to caching)</li>
  ///   <li>Violin plots</li>
  ///   <li>Credible intervals and regions</li>
  ///   <li>Calculation of Bayes factors with significance based on the Jeffreys scale</li>
  ///   <li>Triangle plots</li>
  ///   <li>Study of covariance matrix stability</li>
  /// </ol>
  ///
  /// More options are described here:
  /// https://github.com/mach3-software/MaCh3/wiki/09.-Bayesian-Analysis,-Plotting-and-MCMC-Processor
  ///
  /// <b>@ref GetPenaltyTerm.cpp "GetPenaltyTerm"</b>
  /// Since xsec, flux, and ND spline systematics are treated as the same
  /// systematic object, the log term cannot be taken directly. This utility
  /// evaluates the correct penalty term:
  /// @code
  /// GetFluxPenaltyTerm MCMCChain.root config
  /// @endcode
  /// Relevant parameters are loaded via the configuration, allowing arbitrary
  /// combinations to be studied. Runtime increases with the number of sets.
  ///
  /// <b>@ref DiagMCMC.cpp "DiagMCMC"</b>
  /// Performs MCMC diagnostics such as autocorrelation and trace plots.
  ///
  /// <b>@ref PlotMCMCDiag.cpp "PlotMCMCDiag"</b>
  /// Plots the output of <i>DiagMCMC</i> and can compare multiple files:
  /// @code
  /// ./PlotMCMCDiag DiagMCMC_file_1.root Label_1, DiagMCMC_file_2.root Label_2 ...
  /// @endcode
  /// Up to four files can be processed simultaneously.
  ///
  /// <b>@ref RHat.cpp "RHat"</b>
  /// Performs the \f$\hat{R}\f$ diagnostic to verify that all chains converged to
  /// the same stationary distribution:
  /// @code
  /// ./RHat Ntoys MCMCchain_1.root MCMCchain_2.root MCMCchain_3.root ...
  /// @endcode
  ///
  /// <b>@ref CombineMaCh3Chains.cpp "CombineMaCh3Chains"</b>
  /// Combines chain files produced by MCMC, enforcing that all inputs were
  /// generated with identical software versions and configuration:
  /// @code
  /// CombineMaCh3Chains [-h] [-c [0-9]] [-f] [-o <output file>] file1.root [file2.root ...]
  /// @endcode
  ///
  /// Options:
  /// - <tt>-c</tt> Target compression level (default 1, consistent with <tt>hadd</tt>)
  /// - <tt>-f</tt> Force overwrite if the output file already exists
  /// - <tt>-h</tt> Print usage message and exit
  ///
  /// If no output name is specified, the first input file name is reused.
  ///
  /// <b>@ref SmearChain.cpp "SmearChain"</b>
  /// Allows smearing of contours. Useful when a study shows that the evaluated
  /// uncertainty set does not fully cover the analysis needs:
  /// @code
  /// SmearChain MCMCchain.root Config.yaml
  /// @endcode
  ///
  /// <b>@ref ReweightMCMC.cpp "ReweightMCMC"</b>
  /// Enables chain reweighting to test alternative prior choices without rerunning
  /// the MCMC. Commonly used to study the impact of reactor constraints on
  /// \f$\theta_{13}\f$:
  /// @code
  /// ReweightMCMC Config.yaml MCMCchain.root
  /// @endcode

  /// @defgroup SamplesAndParameters Implementing Samples and Parameters
  /// @brief Classes responsible for handling samples and parameters.
  ///
  /// # Introduction
  /// The SampleHandler classes are the main interface for storing information about the samples used in analysis.
  /// Practically, this involves storing the number of events predicted in each analysis bin for each sample,
  /// as well as modifying this for a given set of systematic and oscillation parameter values (i.e., "reweighting"
  /// the nominal Monte-Carlo prediction). Therefore, the SampleHandler class also interacts with many other classes
  /// in MaCh3, especially the @ref ParameterHandlerGeneric and @ref SplineBase. In turn, the @ref FitterBase class
  /// obtains likelihood values by comparing the MC prediction with data in the SampleHandler class.
  ///
  /// Each experiment needs to create a SampleHandler experiment class that inherits from the @ref SampleHandlerFD
  /// class in the core repository.
  ///
  /// @warning The SampleHandlerFD class will be renamed in the future to avoid confusion, as it can be used
  /// for the Near Detector as well, not only the Far Detector (FD).
  ///
  /// # Constructing a SampleHandler Experiment Class
  /// The main purpose of any SampleHandler class is to contain all information required to make MC predictions
  /// for a given set of systematic parameter values. To achieve this, the SampleHandler object reads information
  /// from different input files and keeps track of them in internal data structures.
  /// For flexibility in loading various experiment formats, the function
  /// @ref SampleHandlerFD::SetupExperimentMC is declared pure virtual.
  ///
  /// ## The Event Struct
  /// The @ref SampleHandlerFD class stores MC information using the @ref EventInfo struct.
  /// Some variables of @ref EventInfo, such as @ref EventInfo::KinVar, need to refer to experiment-specific structures.
  /// This is mostly handled via @ref SampleHandlerFD::GetPointerToKinematicParameter.
  ///
  /// # Setting Up Systematics
  /// Systematic parameters are handled via @ref TypeParameterBase.
  /// Note that the actual parameters, including prior values and errors,
  /// are defined in @ref ParameterHandlerGeneric. However, their impact
  /// on samples is largely implemented in @ref SampleHandlerFD.
  ///
  /// ## Norm Parameters
  /// @ref NormParameter are Simple parameters that work as normalizations for subsets of events.
  /// Events are selected based on kinematic cuts. For example, events with
  /// TrueQ2 in the range [0.5, 1.0] can be selected.
  ///
  /// Example YAML configuration:
  /// @code{yaml}
  /// - Systematic:
  ///     Names:
  ///       FancyName: Norm_Param_1
  ///     KinematicCuts:
  ///       - TrueQ2: [0.5, 1.0]
  ///     Type: Norm
  /// @endcode
  ///
  /// The actual bins are defined when calling @ref SampleHandlerFD::SetupNormParameters,
  /// while the actual values of TrueQ2 are returned using @ref SampleHandlerFD::ReturnKinematicParameter.
  ///
  /// ## Spline Parameters
  /// @ref SplineParameter or response functions are parameters with more complex behavior, often requiring
  /// calculations of higher-order polynomials. Several types of interpolation are available via
  /// @ref SplineInterpolation. Actual weights are calculated via the Spline class, either in a binned
  /// approach via @ref BinnedSplineHandler or event-by-event via @ref SMonolith.
  /// Initialization is handled via @ref SampleHandlerFD::SetupSplines.
  ///
  /// ## Oscillation Parameter
  /// @ref OscillationParameter are handled via @ref OscillationHandler, which is a wrapper around
  /// [NuOscillator](https://github.com/dbarrow257/NuOscillator). This library provides access
  /// to a variety of oscillation engines.
  /// @warning Parameters must be defined exactly as expected by [NuOscillator](https://github.com/dbarrow257/NuOscillator)!
  ///
  /// ## FunctionalParameters
  /// @ref FunctionalParameter represent shifts to kinematical variables or other complex responses
  /// that are not handled by other parameter types. Shifts are applied via
  /// @ref SampleHandlerFD::ApplyShifts (virtual), which can be overridden to implement custom responses.
  /// Functional parameters must be registered via @ref SampleHandlerFD::RegisterIndividualFunctionalParameter.
  /// This informs MaCh3 which functional parameters are available; the configuration file determines which are actually used.
  ///
  /// ## Special Step Proposal
  /// Most parameters are assumed to have Gaussian or flat priors. However, some require special treatment,
  /// mostly for oscillation parameters, though any parameter can be affected.
  /// Handled @ref ParameterHandlerBase::SpecialStepProposal
  ///
  /// ### Circular Bounds
  /// Parameters like delta_CP are defined between -π and +π but can wrap around continuously.
  /// Hence are called @ref ParameterHandlerBase::CircularParBounds
  ///
  /// Example YAML configuration:
  /// @code{yaml}
  /// - Systematic:
  ///     Names:
  ///       FancyName: delta_cp
  ///     SpecialProposal:
  ///       CircularBounds: [-3.141592, 3.141592]
  /// @endcode
  ///
  /// ### Flip Parameter Value
  /// Parameters like delta_M2_32 can @ref ParameterHandlerBase::FlipParameterValue between normal and inverted ordering.
  ///
  /// Example YAML configuration:
  /// @code{yaml}
  /// - Systematic:
  ///     Names:
  ///       FancyName: sin2th_23
  ///     SpecialProposal:
  ///       FlipParameter: 0.5112  # Flip octant around point of maximal disappearance
  /// @endcode
